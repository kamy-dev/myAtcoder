# Review memo

### Data structure

Queue に関する基本問題  
https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/ALDS1_3_B

## Point

### 1. ラウンドロビンスケジューリング

- CPUが各プロセスを処理する際に使われるアルゴリズム

### 2. 計算量の観点

- 今回は標準ライブラリを使わずに実装したが、実行時間が3.2sと遅い。  
  これは、Python標準ライブラリ `collection.deque` クラスを利用すると高速になる。  
  理由は、dequeクラスで構成されたリストは、<b>双方向連結リスト</b> であるためである。

#### 参考

- [双方向連結リスト](https://qiita.com/gonbe/items/695671ae751ce6717ffb)

### 3. リングバッファ

配列を用いたキューの実装において、以下の変数と関数を利用するとする。

1. `queue`:       データを格納するための1次元配列
2. `head`:        先頭ポインタであるint型変数 (※ 常に0とは限らない)
3. `tail`:        末尾ポインタであるint型変数
4. `enqueue(x)`:  キューに要素xを追加する関数 (tailを1 増やす)
5. `dequeue()`:   キューの先頭から要素を取り出す関数 (headを1 増やす)

配列によってキューを実装すると、tailが配列の領域を超えた時点でオーバーフローする。
そのために、`dequeue()` の時にheadを常に0に戻すようにすると、配列内のすべての値を左に寄せる必要があるので、これだけでO(n)の計算が必要になる。

ここで、**リングバッファ** が使える。 

---

リングバッファのサイズは固定ではなく、最初にn個分の配列を確保します。

ラウンドロビンの場合、同時にキューに入るプロセスの数は最大でもn個なので、サイズnのリングバッファで足ります。nがどんなに大きくても、最初にその分だけ確保すれば問題ありません。

リングバッファの利点は、`pop(0)` のように要素をずらす必要がない点です。headとtailの2つのインデックスを管理して、末尾に到達したら `% n` で先頭に戻します。

```python
head = 0
tail = 0

# enqueue
queue[tail] = value
tail = (tail + 1) % n

# dequeue
value = queue[head]
head = (head + 1) % n
```

これで全操作が O(1) になるので、`deque` を使わなくてもキューを効率的に実装できます。

